MODULE CLOUDSC_GLOBAL_STATE_MOD
  ! Driver module to manage the setup and teardown of the dwarf memory state
  USE PARKIND1, ONLY: JPIM, JPRB
  USE YOMPHYDER, ONLY: STATE_TYPE
  USE YOECLDP, ONLY: NCLV
  USE LOAD_STATE_MOD, ONLY: QUERY_DIMENSIONS, LOAD_AND_EXPAND, LOAD_AND_EXPAND_STATE, INITIALISE_PARAMETERS

  IMPLICIT NONE

  TYPE CLOUDSC_GLOBAL_STATE
    ! Memory state containing raw fields annd tendencies for CLOUDSC dwarf
    !
    ! Note that the global state has an additional outermost block
    ! dimension allocated for each field variable.
    INTEGER(KIND=JPIM)                   :: NPROMA, KLEV    ! Grid points and vertical levels per block
    INTEGER(KIND=JPIM)                   :: NGPTOT, NBLOCKS ! Total number of grid points and blocks
    INTEGER(KIND=JPIM)                   :: KFLDX 
    LOGICAL                              :: LDSLPHY 
    LOGICAL                              :: LDMAINCALL      ! T if main call to cloudsc
    REAL(KIND=JPRB)                      :: PTSPHY          ! Physics timestep

    ! Input field variables and tendencies
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PLCRIT_AER(:,:,:) 
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PICRIT_AER(:,:,:) 
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PRE_ICE(:,:,:) 
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PCCN(:,:,:)     ! liquid cloud condensation nuclei
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PNICE(:,:,:)    ! ice number concentration (cf. CCN)

    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PT(:,:,:)       ! T at start of callpar
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PQ(:,:,:)       ! Q at start of callpar
    TYPE(STATE_TYPE), POINTER            :: TENDENCY_CML(:) ! cumulative tendency used for final output
    TYPE(STATE_TYPE), POINTER            :: TENDENCY_TMP(:) ! cumulative tendency used as input
    TYPE(STATE_TYPE), POINTER            :: TENDENCY_LOC(:) ! local tendency from cloud scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PVFA(:,:,:)     ! CC from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PVFL(:,:,:)     ! Liq from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PVFI(:,:,:)     ! Ice from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PDYNA(:,:,:)    ! CC from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PDYNL(:,:,:)    ! Liq from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PDYNI(:,:,:)    ! Liq from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PHRSW(:,:,:)    ! Short-wave heating rate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PHRLW(:,:,:)    ! Long-wave heating rate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PVERVEL(:,:,:)  ! Vertical velocity
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PAP(:,:,:)      ! Pressure on full levels
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PAPH(:,:,:)     ! Pressure on half levels
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PLSM(:,:)       ! Land fraction (0-1) 
    LOGICAL,         POINTER, CONTIGUOUS :: LDCUM(:,:)      ! Convection active
    INTEGER(KIND=JPIM),POINTER,CONTIGUOUS:: KTYPE(:,:)      ! Convection type 0,1,2
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PLU(:,:,:)      ! Conv. condensate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PLUDE(:,:,:)    ! Conv. detrained water 
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PSNDE(:,:,:)    ! Conv. detrained snow
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PMFU(:,:,:)     ! Conv. mass flux up
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PMFD(:,:,:)     ! Conv. mass flux down
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PA(:,:,:)       ! Original Cloud fraction (t)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PEXTRA(:,:,:,:) ! extra fields
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PCLV(:,:,:,:) 
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PSUPSAT(:,:,:)

    ! Output fields used for validation
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PCOVPTOT(:,:,:) ! Precip fraction
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PRAINFRAC_TOPRFZ(:,:) 
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQLF(:,:,:)   ! Flux of liquid
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQIF(:,:,:)   ! Flux of ice
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFCQLNG(:,:,:)  ! -ve corr for liq
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFCQNNG(:,:,:)  ! -ve corr for ice
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQRF(:,:,:)   ! Flux diagnostics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQSF(:,:,:)   ! for DDH, generic
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFCQRNG(:,:,:)  ! rain
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFCQSNG(:,:,:)  ! snow
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQLTUR(:,:,:) ! liquid flux due to VDF
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQITUR(:,:,:) ! ice flux due to VDF
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFPLSL(:,:,:)   ! liq+rain sedim flux
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFPLSN(:,:,:)   ! ice+snow sedim flux
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFHPSL(:,:,:)   ! Enthalpy flux for liq
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFHPSN(:,:,:)   ! Enthalp flux for ice

    ! Underlying data buffers for AOSOA allcoated STATE_TYPE arrays
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: B_CML(:,:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: B_TMP(:,:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: B_LOC(:,:,:,:)
  CONTAINS
    PROCEDURE :: LOAD => CLOUDSC_GLOBAL_STATE_LOAD
  END TYPE CLOUDSC_GLOBAL_STATE

  INTERFACE FIELD_INIT
     PROCEDURE FIELD_INIT_R1, FIELD_INIT_R2, FIELD_INIT_R3, FIELD_INIT_STATE
  END INTERFACE FIELD_INIT

CONTAINS

  SUBROUTINE FIELD_INIT_R1(FIELD, NPROMA,NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: FIELD(:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NBLOCKS))

    !OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B)
    DO B=1, NBLOCKS
       FIELD(:,B) = 0.0_JPRB
    END DO
  END SUBROUTINE FIELD_INIT_R1

  SUBROUTINE FIELD_INIT_R2(FIELD, NPROMA, NLEV, NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: FIELD(:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NLEV, NBLOCKS))

    !OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B)
    DO B=1, NBLOCKS
       FIELD(:,:,B) = 0.0_JPRB
    END DO
  END SUBROUTINE FIELD_INIT_R2

  SUBROUTINE FIELD_INIT_R3(FIELD, NPROMA, NLEV, NDIM, NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: FIELD(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NDIM, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NLEV, NDIM, NBLOCKS))

    !OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B)
    DO B=1, NBLOCKS
       FIELD(:,:,:,B) = 0.0_JPRB
    END DO
  END SUBROUTINE FIELD_INIT_R3

  SUBROUTINE FIELD_INIT_STATE(STATE, BUFFER, NPROMA, NLEV, NDIM, NBLOCKS)
    ! Allocate empty state struct array
    !
    ! Note, the resulting AOSOA pattern is a pain to roll by hand in Fortran
    ! and could be done either via parameterized derived types or templating.
    TYPE(STATE_TYPE), POINTER, INTENT(INOUT) :: STATE(:)
    REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: BUFFER(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NDIM, NBLOCKS
    INTEGER(KIND=JPIM) :: B, NFIELDS

    NFIELDS = 6+NDIM
    ALLOCATE(STATE(NBLOCKS))
    ALLOCATE(BUFFER(NPROMA, NLEV, NFIELDS, NBLOCKS))

    !OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B)
    DO B=1, NBLOCKS
       STATE(B)%U => BUFFER(:,:,1,B)
       STATE(B)%V => BUFFER(:,:,2,B)
       STATE(B)%T => BUFFER(:,:,3,B)
       STATE(B)%O3 => BUFFER(:,:,4,B)
       STATE(B)%Q => BUFFER(:,:,5,B)
       STATE(B)%A => BUFFER(:,:,6,B)
       STATE(B)%CLD => BUFFER(:,:,7:NFIELDS,B)
    END DO
  END SUBROUTINE FIELD_INIT_STATE

  SUBROUTINE CLOUDSC_GLOBAL_STATE_LOAD(THIS, NPROMA, NGPTOT)
    ! Load reference input data via serialbox
    CLASS(CLOUDSC_GLOBAL_STATE) :: THIS
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT

    INTEGER(KIND=JPIM) :: KLON, NBLOCKS

    NBLOCKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)
    CALL QUERY_DIMENSIONS(KLON, THIS%KLEV, THIS%KFLDX)

    CALL LOAD_AND_EXPAND('PLCRIT_AER', THIS%PLCRIT_AER, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PICRIT_AER', THIS%PICRIT_AER, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PRE_ICE', THIS%PRE_ICE, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PCCN', THIS%PCCN, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PNICE', THIS%PNICE, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PT', THIS%PT, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PQ', THIS%PQ, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PVFA', THIS%PVFA, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PVFL', THIS%PVFL, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PVFI', THIS%PVFI, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PDYNA', THIS%PDYNA, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PDYNL', THIS%PDYNL, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PDYNI', THIS%PDYNI, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PHRSW', THIS%PHRSW, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PHRLW', THIS%PHRLW, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PVERVEL', THIS%PVERVEL, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PAP', THIS%PAP, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PAPH', THIS%PAPH, KLON, THIS%KLEV+1, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PLSM', THIS%PLSM, KLON, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('LDCUM', THIS%LDCUM, KLON, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('KTYPE', THIS%KTYPE, KLON, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PLU', THIS%PLU, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PLUDE', THIS%PLUDE, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PSNDE', THIS%PSNDE, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PMFU', THIS%PMFU, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PMFD', THIS%PMFD, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PA', THIS%PA, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PCLV', THIS%PCLV, KLON, THIS%KLEV, NCLV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND('PSUPSAT', THIS%PSUPSAT, KLON, THIS%KLEV, NPROMA, NGPTOT, NBLOCKS)
    ! Note: The 0-sized array (KFLDX=0) seems to create problems when filled with
    ! data from the C-backend, causing memory corruption if enabled.
    ! CALL LOAD_AND_EXPAND('PEXTRA', THIS%PEXTRA, KLON, THIS%KLEV, THIS%KFLDX, NPROMA, NGPTOT, NBLOCKS)

    ! The STATE_TYPE arrays are tricky, as the AOSOA layout needs to be expictly
    ! unrolled at every step, and we rely on dirty hackery to do this.
    CALL FIELD_INIT(THIS%TENDENCY_LOC, THIS%B_LOC, NPROMA, THIS%KLEV, NCLV, NBLOCKS)
    CALL LOAD_AND_EXPAND_STATE('TENDENCY_CML', THIS%TENDENCY_CML, THIS%B_CML, &
         & KLON, THIS%KLEV, NCLV, NPROMA, NGPTOT, NBLOCKS)
    CALL LOAD_AND_EXPAND_STATE('TENDENCY_TMP', THIS%TENDENCY_TMP, THIS%B_TMP, &
         & KLON, THIS%KLEV, NCLV, NPROMA, NGPTOT, NBLOCKS)

    ! Output fields are simply allocated and zero'd
    CALL FIELD_INIT(THIS%PRAINFRAC_TOPRFZ, NPROMA, NBLOCKS)
    CALL FIELD_INIT(THIS%PCOVPTOT, NPROMA, THIS%KLEV, NBLOCKS)
    CALL FIELD_INIT(THIS%PFSQLF, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFSQIF, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFCQLNG, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFCQNNG, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFSQRF, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFSQSF, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFCQRNG, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFCQSNG, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFSQLTUR, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFSQITUR, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFPLSL, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFPLSN, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFHPSL, NPROMA, THIS%KLEV+1, NBLOCKS)
    CALL FIELD_INIT(THIS%PFHPSN, NPROMA, THIS%KLEV+1, NBLOCKS)

    ! This is still based on setting module variables!
    CALL INITIALISE_PARAMETERS(THIS%PTSPHY)

  END SUBROUTINE CLOUDSC_GLOBAL_STATE_LOAD

  SUBROUTINE CLOUDSC_GLOBAL_STATE_VALIDATE()
    ! Validate the correctness of output against reference data

  END SUBROUTINE CLOUDSC_GLOBAL_STATE_VALIDATE

END MODULE CLOUDSC_GLOBAL_STATE_MOD
